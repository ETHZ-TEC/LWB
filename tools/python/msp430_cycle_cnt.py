#!/usr/bin/env python

'''
2014, Reto Da Forno
v1.15

counts the number of cycles of a function (assembly language)
this script is compatible with the MSP430 instruction set and is intended to be used with the .asm files generated by CCS for the MSP430FR5969

tips for balancing the code:
- make the functions you want to balance as short as possible
- balance functions piece by piece (where possible), try to balance each if/else separately
- insert dummy assignments to a volatile variable to make it easier to identify branches of execution

note:
- instructions involving the program counter (PC) have a different cycle count, but are not handled separately in this script
- the c-code should be embedded into the asm file (select this option in the advanced compiler settings / assembler options in CCS)
'''

import sys
import os
import re


# --- look-up tables for instructions (for MSP430FR5969 see user guide p. 123 - 125 and 134 - 136); note: the following tables are NOT complete! ---

# special (single operand) instructions with constant execution time regardless of accessing mode
asm_jump_instr = { 'jmp' : 2, 'jne' : 2, 'jeq' : 2, 'jz': 2, 'jnz' : 2, 'jlo' : 2, 'jn' : 2, 'jge' : 2, 'jl' : 2, 'jc' : 2, 'jnc' : 2, 'reti' : 5, 'ret' : 4, 'reta': 5 } 

# special single operand instructions (note: ops on PC are treated as single operand instructions)
asm_instr1 = [{ 'rra' : 1, 'rrc' : 1, 'swpb' : 1, 'sxt' : 1, 'push' : 3, 'call' : 4, 'calla' : 5, 'br' : 3, 'pushx' : 4, 'pushx.b' : 4, 'pushx.a' : 5, 'popx' : 3, 'popx.b' : 3, 'popx.a' : 4 },  # addressing mode 0: Rn
              { 'rra' : 3, 'rrc' : 3, 'swpb' : 3, 'sxt' : 3, 'push' : 3, 'call' : 4, 'calla' : 6, 'br' : 4, 'pushx' : 4, 'pushx.b' : 4, 'pushx.a' : 6, 'popx' : 0, 'popx.b' : 0, 'popx.a' : 0 },  # mode 1: @Rn
              { 'rra' : 3, 'rrc' : 3, 'swpb' : 3, 'sxt' : 3, 'push' : 3, 'call' : 4, 'calla' : 6, 'br' : 4, 'pushx' : 4, 'pushx.b' : 4, 'pushx.a' : 6, 'popx' : 0, 'popx.b' : 0, 'popx.a' : 0 },  # mode 2: @Rn+
              { 'rra' : 0, 'rrc' : 0, 'swpb' : 0, 'sxt' : 0, 'push' : 3, 'call' : 4, 'calla' : 5, 'br' : 3, 'pushx' : 4, 'pushx.b' : 4, 'pushx.a' : 5, 'popx' : 0, 'popx.b' : 0, 'popx.a' : 0 },  # mode 3: #N
              { 'rra' : 4, 'rrc' : 4, 'swpb' : 4, 'sxt' : 4, 'push' : 4, 'call' : 5, 'calla' : 5, 'br' : 5, 'pushx' : 5, 'pushx.b' : 5, 'pushx.a' : 7, 'popx' : 5, 'popx.b' : 5, 'popx.a' : 7 },  # mode 4: x(Rn)
              { 'rra' : 4, 'rrc' : 4, 'swpb' : 4, 'sxt' : 4, 'push' : 4, 'call' : 5, 'calla' : 7, 'br' : 5, 'pushx' : 5, 'pushx.b' : 5, 'pushx.a' : 7, 'popx' : 5, 'popx.b' : 5, 'popx.a' : 7 },  # mode 5: lbl
              { 'rra' : 4, 'rrc' : 4, 'swpb' : 4, 'sxt' : 4, 'push' : 4, 'call' : 6, 'calla' : 7, 'br' : 5, 'pushx' : 5, 'pushx.b' : 5, 'pushx.a' : 7, 'popx' : 5, 'popx.b' : 5, 'popx.a' : 7 }]  # mode 6: &lbl
              
# look-up table for addressing modes; see get_src_addr_mode() and get_dest_addr_mode() 
asm_instr2 = [[1, 4, 4, 4],    # src addressing mode 0; columns: addressing modes for destination operand, see get_dest_addr_mode()
              [2, 5, 5, 5],    # mode 1
              [2, 5, 5, 5],    # mode 2
              [2, 5, 5, 5],    # mode 3
              [3, 6, 6, 6],    # mode 4
              [3, 6, 6, 6],    # mode 5
              [3, 6, 6, 6]]    # mode 6

# look-up table for addressing mode of the extended instruction set (MSP430X); note: operations involving the PC have again different no. cycles (but is not handled here)
asm_ext_instr2 = [[2, 5, 5, 5, 2, 7,  7,  7],    # mode 0 (columns: first 4 for .b/.w ops, next 4 for .a ops)
                  [3, 6, 6, 6, 4, 9,  9,  9],    # mode 1
                  [3, 6, 6, 6, 4, 9,  9,  9],    # mode 2
                  [3, 6, 6, 6, 3, 8,  8,  8],    # mode 3
                  [4, 7, 7, 7, 5, 10, 10, 10],   # mode 4
                  [4, 7, 7, 7, 5, 10, 10, 10],   # mode 5
                  [4, 7, 7, 7, 5, 10, 10, 10]]   # mode 6

# emulated instructions
asm_emul_instr = { 'tst.w'  : 'cmp.w    #0,', 
                   'tst.b'  : 'cmp.b    #0,', 
                   'tst'    : 'cmp      #0,',
                   'clr.w'  : 'mov.w    #0,',
                   'clr.b'  : 'mov.b    #0,',
                   'clr'    : 'mov      #0,',
                   'dec.w'  : 'sub.w    #1,',
                   'dec.b'  : 'sub.b    #1,',
                   'dec'    : 'sub      #1,',
                   'decd.w' : 'sub.w    #2,',
                   'decd.b' : 'sub.b    #2,',
                   'decd'   : 'sub      #2,',
                   'nop'    : 'mov      r3, r3',
                   'pop'    : 'mov      @SP+,' }

# constants permanently in registers
const_generators = { '#0', '#-1', '#1', '#2', '#4', '#8', 'sp', 'sr' }      # note: treat sp and sr as constant generators (in fact, sp = r1 and sr = r2)

# do not change these values
code_listing_only         = 0
dis_file_type             = 0
print_ccode_for_each_path = 0


def get_src_addr_mode(operand):
    # the different addressing modes: reg, @reg, @reg+, #LABEL, ofs(reg), EDE, &EDE
    if '@' in operand:
        if '+' in operand:
            return 2
        return 1
    elif '#' in operand:
        return 3        
    elif '(' in operand:    # relative offset
        return 4
    elif '&' in operand:    # absolute address
        return 6
    elif 'r' == operand[0]: # register operation
        return 0
    return 5                # EDE


def get_dest_addr_mode(operand):
    # the different addressing modes: reg, ofs(reg), EDE, &EDE
    if '(' in operand:
        return 1
    elif '&' in operand:
        return 3
    elif 'r' == operand[0]:
        return 0
    return 2


def read_asm_file(filename, funcname):
    global asm_emul_instr, dis_file_type
    try:
        if os.path.splitext(filename)[1] == ".dis":
            dis_file_type = 1
            if not code_listing_only:
                print "error: file type .dis is currently not supported (use the flag 'list' instead to display the asm code)"
                return False
        if dis_file_type:
            funcname = "<" + funcname + ">:"
        else:
            funcname = funcname + ":"
        print "searching for label " + funcname + " in file " + filename + "..."
        content = []
        start = False
        c = 0
        for line in open(filename):
            if not start and funcname in line:
                start = True
            elif start:
                if line.startswith(";***"):                                     # the end-of-function marker (note: RET is not a good marker!)
                    break
                
                if dis_file_type:
                    if line.find("\t") is not -1 and len(line) > 23:
                        line = line[23:]                                        # remove the first 23 characters
                       
                elif line.find(".dwtag") is not -1:                             
                    line = line[0:line.find(".dwtag") - 1]                      # remove .dwtag's (only for CCS files)
                    
                if line.find(";") is not -1:                                    # remove comments (except for C code)
                    if line.startswith(";**"):
                        line = re.sub(r'[\s0-9]+-+', r' ', line, re.I)          # remove some characters
                    else:   
                        line = line[0:line.find(";")]                           # remove comments
                        
                line = line.strip().lower()                                     # remove leading and trailing whitespacing and newlines
                
                if len(line) > 0 and line[0] is not '.' and (line[0] is not '$' or line.find(':') is not -1):     # ignore empty lines and lines starting with a dot
                    # replace emulated instructions
                    instr = re.match(r'^([a-z.]+)', line)
                    if instr:
                        if instr.group(1) in asm_emul_instr:
                            line = line.replace(instr.group(1), asm_emul_instr[instr.group(1)])
                    content.append(line)
                    
        if not start:
            print "label '" + funcname + "' not found in '" + filename + "'"
        else:
            print "label '" + funcname + "' extracted (" + str(len(content)) + " lines)"
            return content
    except IOError as e:
        print "I/O error: " + e.strerror
    return False

# END of read_asm_file()



def find_label(code, label):
    for c, line in enumerate(code):
        if line.startswith(";"):
            continue
        if label in line:
            return c
    return -1

# END of find_label()



# compute the number of cycles for a single operand instruction
def compute_cycles_single(instr, prev_instr):
    global asm_instr1, asm_jump_instr
  
    op1    = instr.group(2)
    instr  = instr.group(1)
    
    if op1 == 'pc':
        print "Warning: program counter is operand, computed no. of cycles for " + instr + " might be invalid"
        
    if op1 == 'sp':
        op1 = 'r1'
    if op1 == 'sr':
        op1 == 'r2'

    # is it a jump instruction?        
    if instr in asm_jump_instr:
        #print "special instruction: " + instr + " (" + str(asm_jump_instr[instr]) + " cycles)"
        # note: according to http://e2e.ti.com/support/microcontrollers/msp430/f/166/p/101382/356887#356887, a jump takes 3 cycles if a RMW instruction preceeds (such as add, xor, ..)
        # (this issue is not documented in the user guide, but can be observed with the logic analyzer)
        if prev_instr != "" and ('add' in prev_instr or 'or' in prev_instr or 'sub' in prev_instr or 'and' in prev_instr):
            return (asm_jump_instr[instr] + 1), 1
        return asm_jump_instr[instr], 1

    else:
        # get the addressing mode
        mode = get_src_addr_mode(op1)
        #print "addressing mode for " + op1 + " is " + str(mode)
        if instr in asm_instr1[mode]:
            return asm_instr1[mode][instr], 0
            #print "instr " + instr + " (" + str(cycles) + ")"
        else:
            # check whether it is the 'repeat' instruction
            if instr.startswith('rpt'):
                op1 = re.match(r'#([0-9]+)\s+.*', op1)
                if op1 and int(op1.group(1)) > 0:
                    return int(op1.group(1)), 0
                else:
                    print "Invalid operand for instruction " + instr
            print "Unknown instruction detected: " + instr

    return 0, 0

# END of compute_cycles_single()



# compute the number of cycles for a double operand instruction
def compute_cycles_double(instr):
    
    global asm_instr2, asm_ext_instr2, const_generators
  
    op1   = instr.group(2)
    op2   = instr.group(3)
    instr = instr.group(1)
    
    if op2 == 'pc':
        print "Warning: program counter is operand, computed no. of cycles for " + instr + " might be invalid"
  
    # first, check whether it is an MSP430X or a common instruction
    if instr.endswith('x') or 'x.' in instr:
        #print "MSP430X instruction detected: " + instr
    
        # look for constant generator register values in the operands first
        if op1 in const_generators:
            op1 = 'r3'
        if op2 in const_generators:
            op2 = 'r3'
            
        mode  = get_src_addr_mode(op1)   # source operand
        mode2 = get_dest_addr_mode(op2)  # destination operand
        if instr.endswith('a'):
            mode2 = mode2 + 4            # offset: use columns 5 to 8
        cycles = asm_ext_instr2[mode][mode2]
        
        # number of cycles is reduced by 1 or 2 for certain instructions due to 'pipelined architecture'
        if "mov" in instr or "bit" in instr or "cmp" in instr:
            if mode2 > 4:
                cycles = cycles - 2
            elif mode2 > 0 and mode2 < 4:
                cycles = cycles - 1  
            
        return cycles
    
    elif instr.endswith('m') or 'm.' in instr:
        # handle MSP430X special instructions first (e.g. popm, pushm, rram, rrcm, rrum, rlam)
        if instr.endswith('m.a') and int(op1[1:]) > 0:            
            return 2 + 2 * int(op1[1:])
        elif ('popm' in instr or 'pushm' in instr) and int(op1[1:]) > 0:
            return 2 + int(op1[1:])
        elif ('rlam' in instr or 'rrum' in instr or 'rrcm' in instr or 'rram' in instr) and int(op1[1:]) > 0:
            return int(op1[1:])
        
        print "Warning: Unknown instruction or invalid operand. " + instr
        return 0
    
    else:
        # it's a common double operator instruction
                    
        # look for constant generator register values in the operands first
        if op1 in const_generators:
            op1 = 'r3'
        if op2 in const_generators:
            op2 = 'r3'
            
        mode  = get_src_addr_mode(op1)   # source operand
        mode2 = get_dest_addr_mode(op2)  # destination operand
        
        # catch special address instructions (ending in 'a')
        if instr == 'mova' or  instr == 'bra':
            addr_instr_cycles = [1, 3, 3, 2, 4, 4, 4]
            if mode2 > 0:
                if mode > 0:
                    print "Warning: invalid operands for " + instr
                    return 0
                else:
                    return 4
            else:
                return addr_instr_cycles[mode]
        elif instr == 'cmpa' or instr == 'adda' or instr == 'suba':
            if mode == 0:
                return 1
            elif mode == 3:
                return 3
            else:
                return 0
        
        #print "src: " + str(mode) + " dest: " + str(mode2)
        cycles = asm_instr2[mode][mode2]
        # due to 'pipelined architecture', some instructions need fewer cycles to execute (instruction prefetch!)
        if mode2 > 0 and ("mov" in instr or "bit" in instr or "cmp" in instr):
            cycles = cycles - 1     # mov, bit and cmp instr execute in one fewer cycle

        return cycles

# END of compute_cycles_double()



def parse_code(code, first_line, count, c_code, subcount):
    
    global asm_jump_instr, code_listing_only, print_ccode_for_each_path
  
    instr1_pattern = re.compile(r'^([a-z.]+)\s+([^,]+)', re.I)             # single operand instruction
    instr2_pattern = re.compile(r'^([a-z.]+)\s+([^,]+),\s*(.+)', re.I)  # double operand instruction
    c = 0   # count the number of code lines (excluding comments)
    
    prev_instr = ""
    start_cnt = count
    start_lbl = re.match(r'(\$.+):', code[first_line])
    if start_lbl:
        start_lbl = start_lbl.group(1)  # store the label
        
    for i, line in enumerate(code[first_line:]):
        cycles = 0
        jump   = 0
        
        if line.startswith(";"):
            c_code.append(line)
            continue    # skip this line
        c = c + 1
        if line.startswith("$"):
            if code_listing_only:
                # print the sum of the previous instr. cycles before the label
                if count - start_cnt > 0:
                    print "\t" + str(count - start_cnt) + "\t--------------------"
                    start_cnt = count
                print str(c) + "\t  " + line
            continue    # this is just a label, not an instruction
        # get the instruction
        #print line
        instr = instr2_pattern.match(line)
        if instr:
            # this is a double operand instruction
            #print "(1) " + instr.group(1) + " (2) " + instr.group(2) + " (3) " + instr.group(3)            
            cycles = compute_cycles_double(instr)
        else:
            instr = instr1_pattern.match(line)
            if instr:
                # this is a single operand instruction
                #print "(1) " + instr.group(1) + " (2) " + instr.group(2)
                if "call" in instr.group(1) and not code_listing_only:    # function call?             
                    print "function call detected: " + instr.group(2)
                    
                cycles, jump = compute_cycles_single(instr, prev_instr)                
                
                if jump and not code_listing_only:
                    #print "jump found: " + line
                    gotoline = find_label(code, instr.group(2) + ":")       # jump to a label
                    if gotoline < 0:
                        print "error: label '" + instr.group(2) + "' not found (branch ignored)"
                    elif not start_lbl or (start_lbl not in instr.group(2)):  # helps to prevent an endless loop and stack overflow (do not jump to the label at which we started)
                        #print "jump to label " + instr.group(2) + " (count: " + str(count + cycles) + ")"
                        subcount.append(count + cycles - start_cnt)
                        if len(c_code):
                            c_code.append(";** --- " + str(count + cycles - start_cnt) + " cycles")
                        parse_code(code, gotoline, count + cycles, c_code[:], subcount[:])  # recursive call, pass a copy of c_code
                        start_cnt = count + cycles
                    else:                        
                        print "infinite loop detected: recursion stopped"    # warn message
                        
                    if instr.group(1) == "jmp":                        
                        return    # this branch has finished

            else:
                # most likely an instruction with 0 operands (e.g. RET)
                if line in asm_jump_instr:
                    #print "special instruction: " + instr.group(1) + " (" + str(asm_jump_instr[instr.group(1)]) + " cycles)"
                    cycles = asm_jump_instr[line]
                    if not code_listing_only and line.startswith('ret'):
                        count += cycles     # return from function, this is the end of this branch of execution
                        break
                else:
                    print "Unknown instruction: " + line 
        
        if instr:
            prev_instr = instr.group(1)
        else:
            prev_instr = ""
        
        count += cycles
        if cycles == 0:
            print "Warning: number of cycles is zero (invalid instruction)."
        
        if code_listing_only:
            print str(c) + "\t" + str(cycles) + "\t" + line
            # print the sum of the previous instr. cycles if the instruction was a jump
            if jump:
                print "\t" + str(count - start_cnt) + "\t--------------------"
                start_cnt = count
    
    # END of for()
            
    if not code_listing_only:
        subcount.append(count - start_cnt)
        print "cycle count: " + ' + '.join(str(x) for x in subcount) + " = " + str(count) + " (without subroutines)"
        if len(c_code):
            c_code.append(";** --- " + str(count - start_cnt) + " cycles")
            # go through code and find all labels
            labels = []
            for line in c_code:
                lbl = re.match(r'.+(g[0-9]+):', line)
                if lbl:
                    labels.append(lbl.group(1))
            if len(labels):
                print "labels: " + ', '.join(labels)
                
            if print_ccode_for_each_path:
                print "c code:\n"
                for line in c_code:
                    print line
                print "\n"
        else:
            print "c code not available"
                
        print "--------------------\n"
        
    else:
        print "\t" + str(count - start_cnt) + "\t--------------------"

# END of parse_code()


        
# main
if len(sys.argv) > 2:
    if os.path.isfile(sys.argv[1]):
        if len(sys.argv) > 3:           # flag set?
            if sys.argv[3] == 'list' or sys.argv[3] == '-l':
                code_listing_only = 1
            elif sys.argv[3] == 'ccode' or sys.argv[3] == '-c':
                print_ccode_for_each_path = 1
        code = read_asm_file(sys.argv[1], sys.argv[2]) 
        if code is not False:
            # success, now parse the code
            print "\n"            
            parse_code(code, 0, 0, [], [])
            print "\n"
            if not print_ccode_for_each_path or code_listing_only:
                # print the c code
                print "c code:\n"
                for line in code:
                    if line.startswith(';**'):
                        print line
            print "\n"
    else:
        print "file '" + sys.argv[1] + "' not found"
else:
    print "\nusage:\n\t" + os.path.basename(__file__) + " [filename].asm [function_name] (FLAGS)\n\nFLAGS (optional):\n\n\tlist, -l\tcode listing only, no flow analysis\n\tccode, -c\tshow c code for each control flow\n"
